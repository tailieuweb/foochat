const logger = require('../loaders/logger');
const Models = require('../models')
const mongoose =  require('mongoose');

class ChatService {

    static async createRoom(roomName){
        let room = await Models.Room.create({
            name: roomName
        })
        await room.save()
        let rooms = await Models.Room.find()
        logger('info', `room ${roomName} đã được tạo`)                
        return rooms
    }

    static async getAllUsers(){
        const allUsers = await Models.User.find().select('-email -password -friends')
        return allUsers
    }
    static async joinRoom(username, socketId, groupId){
        let group = await Models.Group.findById(mongoose.Types.ObjectId(groupId));
        let room = await Models.Room.findOne({name: group.name});        
        if(room.users.filter(roomMember => roomMember.username === username).length === 0){            
            room.users.push({
                username,
                socketId
            })
        
            await room.save()
        }
        else{
            room.users.map(roomMember => {
                return roomMember.username === username  ? 
                ({...roomMember, socketId}) :
                roomMember
            })
            await room.save();
        }
        room = await Models.Room.find({
            name: group.name
        })
        logger('info', `${username} đã tham gia room ${room[0].name}`)                
        return room
   }

    static async leaveRoom(username, roomId){
        let group = await Models.Group.findById(mongoose.Types.ObjectId(roomId))
        let room = await Models.Room.findOne({
            name: group.name
        })
        if(room){
            await room.leaveRoom(username)
        }
        room = await Models.Room.find({
            name: group.name
        })
        logger('info', `${username} đã rời room ${room[0].name}`)                
        return  room
    }

    /**
     * Setting values for room model
    */
    static async setRooms(){
        try {
            let groups = await Models.Group.find()
            let rooms = await Models.Room.find()
            if (groups){
                for( var i = 0; i < groups.length; i++ ) {
                    if(rooms){
                        if (rooms.every(room => !room.name.includes(groups[i].name))){
                            let room = new Models.Room();
                            room.name = groups[i].name,
                            room.save()
                            }
                        }
                        else{
                            let room = new Models.Room();
                            room.name = groups[i].name,
                            room.save()
                        }
                    }
                return   'Tạo room thành công'
            }
        }
        catch(error){
            return error
        }
    }

    static async getRoomInfo(userId, groupId){
        let group = await Models.Group.findById(mongoose.Types.ObjectId(groupId))
        let user = await Models.User.findById(mongoose.Types.ObjectId(userId))
        let username = user.username    
        let room = group.name
        room = await Models.Room.findOne({
            name: room
        })   
        if(user){
            let response = {
                username,
                room
        }
        return response;
        }
    }

    static async currentUserOnlineFriends(username){
        let user = await Models.User.findOne({
            username: username
        })
        let users = await Models.User.find()
        let onlineUsers = await Models.User.find({'socketId':{$ne: null}});
        let onlineFriends = user.friends.map(friend => ({
            username:friend.userInfo.username,
            isOnline: onlineUsers.some(user => user.username === friend.userInfo.username),
            lastOnline: users.filter( user => user.username === friend.userInfo.username)[0].lastOnline
                }
            )
        )        
        logger('info', `${username} có bạn bè online`)                
        return onlineFriends
    }

    static async getUserSocketId(receiver, sender){
        let userReceiver = await Models.User.findOne({
            username: receiver
        })
        let userSender = await Models.User.findOne({
            username: sender
        })        
        const filteredData = await userSender.filterUserData()
        logger('info', `${sender} kết nối tin nhắn đến ${receiver}`)                

        return {
            socketId: userReceiver.socketId,
            userSender: filteredData
        }
    }
    
    static async logOutCurrentUser(socketId){
        let now = new Date();
        let user = await Models.User.findOne({
            socketId: socketId
        })
        if (user){            
            user.lastOnline = now;
            user.socketId = null;
            await user.save();
            logger('info', `${user.username} đã đăng xuất`)                

        }
    }
    static async setUserSocketId(username, socketId){
        let user = await Models.User.findOne({
            username: username
        })        
        user.socketId = socketId;
        await user.save()
        logger('info', `${username} đã tạo ra một socket id trong database`)                

    }

    static async getOnlineUsers(){
        const users = await Models.User.find();
        const filteredData =  await Models.User.filterData(users);
        let onlineUsers = await Models.User.find({'socketId':{$ne: null}});
        onlineUsers = users.map(user => ({
            username:user.username,
            isOnline: onlineUsers.some(online => online.username === user.username),
            lastOnline: user.lastOnline
            })
        )
        
        return {
            users: filteredData,
            onlineUsers
        }
    }
}

module.exports = ChatService;